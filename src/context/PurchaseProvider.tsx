import { useEffect, useState } from "react";
// wallet provider network
import {
  useConnection,
  useWallet,
  WalletProviderProps,
} from "@solana/wallet-adapter-react";
// style
import("@solana/wallet-adapter-react-ui/styles.css" as any);
// component
import { useNotify } from "hooks/notify";
// context
import PurchaseContext from "context/PurchaseContext";
// idl json
import idl from "utils/idl.json";
import {
  PublicKey,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  Transaction,
  TransactionSignature,
} from "@solana/web3.js";

import * as anchor from "@project-serum/anchor";
import { Program, Provider, BN, Idl } from "@project-serum/anchor";
import {
  Token,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
export function PurchaseProvider(
  props: Omit<WalletProviderProps, "wallets">
): JSX.Element {
  //  notify hook
  const notify = useNotify();
  //  connection
  const { connection } = useConnection();
  const { wallet, publicKey, sendTransaction } = useWallet();
  const [saleInfo, setSaleInfo] = useState<any>(null);
  const [buyer, setBuyer] = useState<any>(null);
  const provider = new Provider(connection, wallet as any, {
    preflightCommitment: "confirmed",
  });

  const program = new Program(
    idl as Idl,
    new PublicKey("H4ApEZcGvYTX8Lw7vTM1R3PEJWN9vjMfmu13UWuUHHdZ"),
    provider
  );
  // reserve pda generated by seeds
  let buyerPda: PublicKey, buyerBump: number;

  // assocated token account for connected wallet, should be USDC token account in production
  let paymentTokenAccount: PublicKey;

  // constant, admin user will initialize sale state to this account
  const SALE_PUBKEY = new PublicKey(
    process.env.NEXT_PUBLIC_SALE_PUBKEY as string
  );

  // pyament_mint from `show_sale` CLI
  const PAYMENT_MINT_PUBKEY = new PublicKey(
    process.env.NEXT_PUBLIC_PAYMENT_MINT_PUBKEY as string
  );

  // treasury_account from `show_sale` CLI

  const TREASURY_PUBKEY = new PublicKey(
    process.env.NEXT_PUBLIC_TREASUERY_PUBKEY as string
  );

  // buyer prefix
  const BUYER = process.env.NEXT_PUBLIC_BUYER as string;

  useEffect(() => {
    (async () => {
      try {
        const saleInfo = await program.account.sale.fetch(SALE_PUBKEY);
        setSaleInfo(saleInfo);
      } catch (err) {
        notify("error", "Unkown error");
      }
    })();
  }, []);

  useEffect(() => {
    (async () => {
      // sale & buyer state
      if (!publicKey) {
        return;
      }

      try {
        const res = await Promise.all([
          // get buyer reserve pda
          PublicKey.findProgramAddress(
            [
              publicKey.toBuffer(),
              Buffer.from(anchor.utils.bytes.utf8.encode(BUYER)),
              SALE_PUBKEY.toBuffer(),
            ],
            program.programId
          ),
          // get token account, we don"t need to check if connected wallet has token account, because they have to pay with this token account
          Token.getAssociatedTokenAddress(
            ASSOCIATED_TOKEN_PROGRAM_ID,
            TOKEN_PROGRAM_ID,
            PAYMENT_MINT_PUBKEY,
            publicKey
          ),
        ]);

        // buyer reserve PDA
        [buyerPda, buyerBump] = res[0];

        // associated token account, in production USDC account for connected wallet
        paymentTokenAccount = res[1];

        await loadSaleInfo();
      } catch (err) {
        notify("error", "Unkown error");
      }
    })();
  }, [publicKey]);

  const loadSaleInfo = async () => {
    try {
      const [saleInfo, buyer] = await Promise.all([
        await program.account.sale.fetch(SALE_PUBKEY),
        await program.account.buyer.fetchNullable(buyerPda),
      ]);
      setSaleInfo(saleInfo);
      setBuyer(buyer);
    } catch (err) {
      notify("error", "Unkown error");
    }
  };

  const purchase = async (depositValue: number) => {
    if (!publicKey) {
      notify("warning", "Please connect your wallet.");
      return;
    }

    if (!paymentTokenAccount) {
      const res = await Promise.all([
        // get buyer reserve pda
        PublicKey.findProgramAddress(
          [
            publicKey.toBuffer(),
            Buffer.from(anchor.utils.bytes.utf8.encode(BUYER)),
            SALE_PUBKEY.toBuffer(),
          ],
          program.programId
        ),
        // get token account, we don"t need to check if connected wallet has token account, because they have to pay with this token account
        Token.getAssociatedTokenAddress(
          ASSOCIATED_TOKEN_PROGRAM_ID,
          TOKEN_PROGRAM_ID,
          PAYMENT_MINT_PUBKEY,
          publicKey
        ),
      ]);

      // buyer reserve PDA
      [buyerPda, buyerBump] = res[0];

      // associated token account, in production USDC account for connected wallet
      paymentTokenAccount = res[1];
    }

    let signature: TransactionSignature = "";

    try {
      const transaction = new Transaction();

      // read buyer pda state
      const buyer = await program.account.buyer.fetchNullable(buyerPda);
      if (!buyer) {
        transaction.add(
          // create buyer reserve account
          await program.instruction.createBuyer(
            { nonce: buyerBump },
            {
              accounts: {
                initializer: publicKey,
                buyer: buyerPda,
                sale: SALE_PUBKEY,
                systemProgram: SystemProgram.programId,
                rent: SYSVAR_RENT_PUBKEY,
              },
            }
          )
        );
      }

      transaction.add(
        // deposit in payment_mint (USDC in production)
        await program.instruction.deposit(
          {
            // deposit amouunt of USDC
            amount: new BN(depositValue * 1e6),
          },
          {
            accounts: {
              initializer: publicKey,
              initializerPaymentToken: paymentTokenAccount,
              treasuryAccount: TREASURY_PUBKEY,
              buyer: buyerPda,
              sale: SALE_PUBKEY,
              tokenProgram: TOKEN_PROGRAM_ID,
            },
          }
        )
      );

      signature = await sendTransaction(transaction, connection);
      notify("info", "Transaction sent:", signature);

      await connection.confirmTransaction(signature, "processed");
      notify("success", "Transaction successful!", signature);

      await loadSaleInfo();
    } catch (err: any) {
      console.log(err.message);
      if (err.message.endsWith("0x177c")) {
        notify("error", "Your deposit is not verified.");
      } else if (err.message.endsWith("0x177b")) {
        notify(
          "error",
          "You cannot purchase more than $5,000 in current phase."
        );
      } else if (err.message.endsWith("0x177a")) {
        notify("error", "You have to purchase at least $10 in current phase.");
      } else if (err.message.endsWith("0x1779")) {
        notify("error", "You don't have enough USDC in your wallet.");
      } else if (err.message.endsWith("0x1775")) {
        notify("error", "Hardcap is reached for current phase");
      } else if (err.message.endsWith("0x1774")) {
        notify("error", "Sale is ended.");
      } else if (err.message.endsWith("0x1773")) {
        notify("error", "Sale is not opened yet.");
      } else if (err.message.endsWith("0x1772")) {
        notify("error", "You are transferring to an invalid treasury account.");
      } else if (err.message.endsWith("0x1771")) {
        notify("error", "You are depositing to an invalid sale account.");
      } else if (err.message.endsWith("0xbc4")) {
        notify("error", "You don't have USDC in your wallet.");
      } else {
        notify("error", "You have rejected transaction.");
      }
    }
  };

  return (
    <PurchaseContext.Provider
      value={{ purchase, saleInfo, buyer }}
      {...props}
    ></PurchaseContext.Provider>
  );
}

export default PurchaseProvider;
